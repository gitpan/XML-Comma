.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Comma::docs::faq 3pm"
.TH XML::Comma::docs::faq 3pm "2007-02-13" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
XML::Comma FAQ \- frequently asked questions about XML::Comma
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::Comma is an information management platform. It was designed to
be used as a core tool for developing Very Large Websites. Comma
specifies an XML-based document definition format, encourages Perl
code to be embedded in these definitions, and specifies an \s-1API\s0 for
manipulating documents and document collections. Comma includes
functionality to store sets of documents in ordered, extensible ways,
and integrates with a relational database to index, sort and retrieve
collections of documents.
.SH "BASIC INFORMATION"
.IX Header "BASIC INFORMATION"
.Sh "How is XML::Comma licensed and distributed?"
.IX Subsection "How is XML::Comma licensed and distributed?"
XML::Comma is Free Software released under the \s-1GNU\s0 General Public
License. For more information about the license, please see
http://www.fsf.org/licenses/gpl.html
.PP
Comma is distributed as a Perl module. The most recent version is
always available at http://xml\-comma.org/download/
.Sh "Is there an XML::Comma web site?"
.IX Subsection "Is there an XML::Comma web site?"
Yes. http://xml\-comma.org/
.Sh "Is there an XML::Comma mailing list?"
.IX Subsection "Is there an XML::Comma mailing list?"
Yes. Please see http://xml\-comma.org/mailing\-list.html
.Sh "What documentation is available?"
.IX Subsection "What documentation is available?"
The \fBXML::Comma User's Guide\fR describes the Comma \s-1API\s0 in detail. It
is available in \s-1HTML\s0 and \s-1PDF\s0. The Guide can be found in the \f(CW\*(C`Comma/docs\*(C'\fR
directory of the distribution, or at:
.PP
.Vb 2
\&  http://xml\-comma.org/guide\-filter.html
\&  http://xml\-comma.org/guide.pdf
.Ve
.SH "CONFIGURATION QUESTIONS"
.IX Header "CONFIGURATION QUESTIONS"
.Sh "Some indexing.t tests are failing on a new XML::Comma install using MySQL; what's going on?"
.IX Subsection "Some indexing.t tests are failing on a new XML::Comma install using MySQL; what's going on?"
Comma relies on MySQL's \*(L"\s-1USE\s0 \s-1DATA\s0 \s-1LOCAL\s0\*(R" function, which has been
disabled by default in MySQL versions 3.23.48 and greater. This change
to MySQL breaks a few of the indexing tests. MySQL can be recompiled
with the option \*(L"\-\-enable\-local\-infile\*(R" to turn back on the \s-1LOCAL\s0
functionality. Or mysqld can be started with the argument
\&\*(L"\-\-local\-infile=1\*(R". See the following piece of MySQL documentation:
.PP
.Vb 1
\&  http://www.mysql.com/doc/en/LOAD_DATA_LOCAL.html
.Ve
.PP
You may also need to pass 'mysql_local_infile=1' as an argument in the
data source name you use to connect (via the \s-1DBI\s0 modules) to
MySQL. The dsn is specified in the Comma/Configuration.pm file. 
.ie n .Sh "I'm trying to use the SimpleC parser.  Why am I getting all of these ""\s-1BEGIN\s0 failed\*(--compilation aborted"" error messages when I try to start Apache?"
.el .Sh "I'm trying to use the SimpleC parser.  Why am I getting all of these ``\s-1BEGIN\s0 failed\*(--compilation aborted'' error messages when I try to start Apache?"
.IX Subsection "I'm trying to use the SimpleC parser.  Why am I getting all of these BEGIN failedcompilation aborted error messages when I try to start Apache?"
As stated in mod_perl documentation at
http://perl.apache.org/docs/1.0/guide/troubleshooting.html#foo_\|__\|__at_\|_dev_null_line_0,
there is no file associated with a handler from mod_perl's
perspective, so \f(CW$0\fR is set to \f(CW\*(C`/dev/null\*(C'\fR.
.PP
If a pre-compiled version of the SimpleC parser is not found by
Inline, Inline tries (using the FindBin module) to figure out its
\&\*(L"current working directory.\*(R" FindBin croaks when \f(CW$0\fR is set to
\&\f(CW\*(C`/dev/null\*(C'\fR, which causes Apache to abort the startup process.
.PP
You can get a compiled version of the parser in the right spot by
simply invoking
.PP
.Vb 1
\&  perl \-MXML::Comma \-e ''
.Ve
.PP
from a command line. Comma asks Inline to install its compiled files
below \f(CW\*(C`XML::Comma\->tmp_directory\*(C'\fR.
.PP
If you are worried about your pre-compiled parser being clobbered
between apache restarts (for example because your tmp_directory is
\&\f(CW\*(C`/tmp\*(C'\fR), you can add a
.PP
.Vb 1
\&  BEGIN { $0 = "/path/to/handler" }
.Ve
.PP
block to your handler script, which will prevent FindBin from
croaking, and allow Inline's compilation step to proceed normally.
.SH "CODE QUESTIONS"
.IX Header "CODE QUESTIONS"
.ie n .Sh "What's the difference between $foo\fP\->\fIbar()\fP and \f(CW$foo\fP\->element('bar')\->\fIget()?"
.el .Sh "What's the difference between \f(CW$foo\fP\->\fIbar()\fP and \f(CW$foo\fP\->element('bar')\->\fIget()\fP?"
.IX Subsection "What's the difference between $foo->bar() and $foo->element('bar')->get()?"
This is really a question about Comma's \*(L"shortcut\*(R" syntax, which
defines a mapping between method calls and the elements of a given
container.
.PP
There is a section on the shortcut syntax in the guide that goes into
more detail, but here is a quick list of the seven possible ways a
shortcut can can be resolved.
.PP
.Vb 8
\&  $x\->foo ( [@args] )                  # becomes:
\&  $x\->method('foo, @args)              # if there is a method "foo"
\&  $x\->element('foo')                   # singular, nested
\&  $x\->elements('foo')                  # plural, nested
\&  $x\->element('foo')\->get()            # singular, non\-nested, no @args 
\&  $x\->element('foo')\->set(@args)       # singular, non\-nested, with @args
\&  $x\->elements_group_get('foo')        # plural, nested, no @args
\&  $x\->elements_group_set('foo', @args) # plural, nested, with @args
.Ve
.Sh "How do I tell how many instances of a given plural element exist?"
.IX Subsection "How do I tell how many instances of a given plural element exist?"
Because the \fIelements()\fR method always tries to return a \*(L"list\*(R" of
elements \*(-- which means that it returns an array in list context and a
reference to an array in scalar context \*(-- you have to do a bit of
extra work to determine how many instances of a plural element
exist. The most concise (and the recommended) way to do this is:
.PP
.Vb 1
\&  my $how_many_foos = scalar ( @{$doc\->elements('foo')} );
.Ve
.Sh "How do I check whether a given element exists, without auto-creating it?"
.IX Subsection "How do I check whether a given element exists, without auto-creating it?"
Comma elements automatically get created when you ask for them. So the
following code first makes a new Doc, then (behind the scenes) makes a
new Element object for you:
.PP
.Vb 1
\&  XML::Comma::Doc\->new ( type=>'Some_Def' )\->element ( "foo" );
.Ve
.PP
This automatic creation (auto\-vivication, in Perl lingo) is almost
always what you want. But there are cases where you need to check
whether an Element already exists before you try to manipulate it. For
example, you might have a nested element that has some required
children \*(-- and you probably only want to create that element when
you're sure you're ready to populate it fully.
.PP
The idiom to do this turns out to be almost the same as the idiom to
check how many instances of a plural element exist, given above:
.PP
.Vb 3
\&  if ( @{$doc\->elements('foo')} ) {
\&    $doc\->foo()\->child ( 'some value' );
\&  }
.Ve
.Sh "What does the \s-1BAD_CONTENT\s0 error that talks about '& found that isn't part of an entity reference' mean?"
.IX Subsection "What does the BAD_CONTENT error that talks about '& found that isn't part of an entity reference' mean?"
You have a problem that boils down to something along these lines:
.PP
.Vb 1
\&  $doc\->element('some_element')\->set ( "foo & bar" );
.Ve
.PP
Element content must be legal \s-1XML\s0 \*(-- so no &lt;, &gt;, or &amp;
characters are allowed. These special characters must be \*(L"escaped\*(R" by
replacing them with their entity codes (respectively &amp;lt;,
&amp;gt;, or &amp;amp;). The \f(CW\*(C`Comma::Util::XML_basic_escape()\*(C'\fR and
\&\f(CW\*(C`Comma::Util::XML_basic_unescape()\*(C'\fR methods are available, as are
shortcut flags for the element \f(CW\*(C`set()\*(C'\fR and \f(CW\*(C`get()\*(C'\fR methods:
.PP
.Vb 3
\&  $doc\->element('some_element()\->set ( "foo & bar", escape=>1 );
\&  $doc\->element('some_element')\->get ( unescape=>1 );
\&  $doc\->some_element ( "foo & bar", escape=>1 );
.Ve
.PP
Note that there is no way to pass the \f(CW\*(C`unescape\*(C'\fR flag in the
shortcut-get syntax (so there are three examples above, rather than
four). It is fair to construe this as a problem with the \s-1API\s0.
.Sh "What's wrong with 'while($iterator++){}' ?"
.IX Subsection "What's wrong with 'while($iterator++){}' ?"
There is a bug in Perl (both versions 5.6.1 and 5.8.0) that leads to a
memory leak in Comma code like this:
.PP
.Vb 4
\&  my $iterator = $index\->iterator();
\&  while ( $iterator++ ) {
\&    ...
\&  }
.Ve
.PP
or:
.PP
.Vb 2
\&  if ( $iterator++ ) {
\&  }
.Ve
.PP
If you use the 'while($iterator++){}' or 'if($iterator++){}', then
your Iterators objects won't ever get garbage\-collected. This is very
often not a problem; any stand-alone script will be fine, the
Iterators will get properly DESTROYed when the script exits. But code
like the above running inside, for example, a web application, can be
a problem. 
.PP
This works fine:
.PP
.Vb 4
\&  my $iterator = $index\->iterator();
\&  while ( ++$iterator ) {
\&    ...
\&  }
.Ve
.PP
The pre-increment may seem a little counter\-intuitive, but the
Iterator class is written to Do The Right Thing for this very common
case. And the pre-increment doesn't trigger the memory leak. And this
is fine, too:
.PP
.Vb 5
\&  my $iterator = $index\->iterator();
\&  while ( $iterator ) {
\&    ...
\&    $iterator++;
\&  }
.Ve
.Sh "What does an error that ends 'sh: /tmp/log.comma: Permission denied' mean?"
.IX Subsection "What does an error that ends 'sh: /tmp/log.comma: Permission denied' mean?"
Comma writes a line about all un-caught errors to a log file. The
location of the log file is controlled by a setting in Comma.pm \*(-- the
default is \f(CW\*(C`/tmp/log.comma/\*(C'\fR. This file probably needs to be writable
by any processes that use the Comma framework. In most installations,
the file is made world-writable (which should tell you that the Comma
log system isn't intended to be used as part of any security auditing
or similar framework \*(-- you should write additional code to handle any
secure reporting that an application might need.)
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
.Sh "Is XML::Comma fast?"
.IX Subsection "Is XML::Comma fast?"
Sure. We don't know of any faster way to develop (or to add new
features to) large-scale applications that manipulate collections of
hundreds of thousands of pieces of messy-but-structured
information. We use it every day, and so do many, many people who
access the web sites we build.
.PP
Oh, wait: you meant, \*(L"does it run fast?\*(R" Well, that's in the eye of
the beholder. Comma's bottleneck is the parsing and object-ifying of
\&\s-1XML\s0 files. The power and flexibility that the \s-1API\s0 gives you comes at
some cost \*(-- a hand\-coded, special-purpose implementation could well
be faster for any single usage.
.PP
However, we've worked hard to make Comma fast enough to be really,
really, useful. For example, Comma's \*(L"Inline\*(R" parser is about twice as
fast as the general-use \s-1XML\s0 parsers against which we've benchmarked it
(because Comma documents aren't allowed to make use of all parts of
the \s-1XML\s0 specification). An experienced designer of large-scale
internet systems will easily be able to structure and tune a
Comma-based system to serve hundreds of thousands of dynamic pages a
day on mid-range x86 boxes.
